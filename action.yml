name: 'PatchLens Go Module Update Analysis'
description: 'Submit request to PatchLens service to analyze a public GitHub repo and validate the dependency update.'
author: 'PatchLens'
branding:
  icon: 'package'
  color: 'blue'

permissions:
  contents: write
  issues: write
  pull-requests: write

inputs:
  directory:
    description: 'Sub-directory containing go.mod (relative to repo root)'
    required: false
    default: ''
  timeout_minutes:
    description: 'Timeout for error retries in minutes'
    required: false
    default: '20'
  github_token:
    description: 'GitHub token for authentication (use secrets.GITHUB_TOKEN)'
    required: true

runs:
  using: composite
  steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.pull_request.head.ref }}
        fetch-depth: 0
        persist-credentials: true

    - name: Setup
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y jq

    - name: Detect module changes
      id: go_mod
      shell: bash
      run: |
        BASE_REF=${{ github.event.pull_request.base.ref }}
        git fetch origin "${BASE_REF}"
        if [[ -z "${{ inputs.directory }}" || "${{ inputs.directory }}" == "." ]]; then
          MODPATH='go.mod'
        else
          MODPATH="${{ inputs.directory }}/go.mod"
        fi
        if git diff --quiet "origin/${BASE_REF}...HEAD" -- "$MODPATH"; then
          echo "changed=false" >> "$GITHUB_OUTPUT"
        else
          echo "changed=true"  >> "$GITHUB_OUTPUT"
        fi

    - name: Skip if no module changes
      if: steps.go_mod.outputs.changed == 'false'
      shell: bash
      run: |
        echo "‚úÖ no changes in go.mod; skipping PatchLens analysis"

    - name: Run PatchLens analysis
      if: steps.go_mod.outputs.changed == 'true'
      id: analysis
      shell: bash
      env:
        HOST: api.patchlens.com
        REPO: ${{ github.event.pull_request.head.repo.clone_url }}
        BRANCH: ${{ github.event.pull_request.base.ref }}
        DIR: ${{ inputs.directory }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        set -euo pipefail

        # prepare path to go.mod
        if [[ -z "${DIR}" || "${DIR}" == "." ]]; then
          GO_MOD="go.mod"
        else
          GO_MOD="${DIR%/}/go.mod"
        fi
        # load and JSON-escape go.mod
        GOMOD_PAYLOAD=$(jq -Rs '.' < "${GO_MOD}")
        # build the request
        PAYLOAD=$(jq -n \
          --arg repo   "${REPO}" \
          --arg branch "${BRANCH}" \
          --arg dir    "${DIR}" \
          --argjson gomod "${GOMOD_PAYLOAD}" \
          '{repo: $repo, branch: $branch, directory: $dir, gomod: $gomod}')

        # submit with retry
        START=$(date +%s)
        TIMEOUT=$(( ${{ inputs.timeout_minutes }} * 60 ))
        until RES=$(curl -sS -X POST "https://${HOST}/analyze-github" \
                       -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                       -H "Content-Type: application/json" \
                       -d "${PAYLOAD}"); do
          NOW=$(date +%s)
          if (( NOW - START >= TIMEOUT )); then
            echo "‚ùå Submission failed after ${TIMEOUT}s" >&2
            exit 1
          fi
          echo "‚ö†Ô∏è Submission failed, retrying in 30s‚Ä¶" >&2
          sleep 30
        done

        echo "‚úÖ Analysis started‚Ä¶"
        JOB_ID=$(echo "${RES}" | jq -r '.id')
        if [[ -z "${JOB_ID}" ]]; then
          echo "‚ùå Error submitting to PatchLens: $(echo "${RES}")"
          exit 1
        fi

        # poll loop
        while true; do
          STAT=$(curl -sS -X POST "https://${HOST}/status" \
            -H "Content-Type: application/json" \
            -d "{\"id\":\"${JOB_ID}\"}")
          CODE=$?
          if [[ "${CODE:-0}" -ne 0 ]]; then
            NOW=$(date +%s)
            if (( NOW - START >= TIMEOUT )); then
              echo "‚ùå Polling failed after ${TIMEOUT}s" >&2
              exit 1
            fi
            echo "‚ö†Ô∏è Status request failed, retry in 30s‚Ä¶" >&2
            sleep 30
            continue
          fi
          # save output for possible end comment
          echo "$STAT" > status.json
          # reset start so timeout only counts during failures
          START=$(date +%s)
          # print any new logs
          echo "${STAT}" | jq -r '.logs[]?' || true

          QUEUED=$(echo "${STAT}" | jq -r '.queued')
          RUNNING=$(echo "${STAT}" | jq -r '.running')

          if [[ "${QUEUED}" == "true" ]]; then
            echo "‚è≥ queued‚Ä¶"
            sleep 10
            continue
          fi

          if [[ "${RUNNING}" == "false" ]]; then
            echo "üìä Final report:"
            echo "${STAT}" | jq '.end_report'
            echo "‚úÖ Done"
            break
          fi

          sleep 10
        done

    - name: Upload report image to PR branch
      if: steps.go_mod.outputs.changed == 'true'
      id: upload_report
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const fs = require('fs');

          const data = JSON.parse(fs.readFileSync('status.json', 'utf8'));
          const chartB64 = data.report_chart64 || data.reportChart64 || '';
          if (!chartB64) {
            core.info('‚ö†Ô∏è No chart data, skipping upload.');
            return;
          }

          const branch   = context.payload.pull_request.head.ref;
          const filepath = `.patchlens/report-${Date.now()}.png`;
          await github.rest.repos.createOrUpdateFileContents({
            owner:   context.repo.owner,
            repo:    context.repo.repo,
            path:    filepath,
            message: `PatchLens report for PR #${context.issue.number}`,
            content: chartB64,
            branch,
          });

          // Build raw URL and set it as a step output
          const url = `https://raw.githubusercontent.com/${context.repo.owner}/` +
                      `${context.repo.repo}/${branch}/${filepath}`;
          core.setOutput('report_url', url);

    - name: Comment results on PR
      if: steps.go_mod.outputs.changed == 'true'
      uses: actions/github-script@v7
      env:
        REPORT_URL: ${{ steps.upload_report.outputs.report_url }}
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const url = process.env.REPORT_URL;
          if (!url) {
            core.info('‚ö†Ô∏è No report URL, skipping comment.');
            return;
          }

          // delete old comments
          const { data: comments } = await github.rest.issues.listComments({
            owner:        context.repo.owner,
            repo:         context.repo.repo,
            issue_number: context.issue.number,
            per_page:     100
          });
          for (const c of comments) {
            if (c.user.login === 'github-actions[bot]' &&
                c.body.startsWith('## üîç PatchLens Analysis Report')) {
              await github.rest.issues.deleteComment({
                owner:      context.repo.owner,
                repo:       context.repo.repo,
                comment_id: c.id
              });
            }
          }

          // post the new comment
          await github.rest.issues.createComment({
            owner:        context.repo.owner,
            repo:         context.repo.repo,
            issue_number: context.issue.number,
            body: [
              '## üîç PatchLens Analysis Report',
              '',
              `![PatchLens Report](${url})`,
              ''
            ].join('\n')
          });

