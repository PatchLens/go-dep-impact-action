name: 'PatchLens Go Module Update Analysis'
description: 'Analyze Go module dependency updates using PatchLens tool'
author: 'PatchLens'
branding:
  icon: 'package'
  color: 'blue'

permissions:
  contents: write
  issues: write
  pull-requests: write

inputs:
  directory:
    description: 'Sub-directory containing go.mod (relative to repo root)'
    required: false
    default: ''
  go_version:
    description: 'Go version to use for analysis'
    required: false
    default: '1.24'
  github_token:
    description: 'GitHub token for private modules (optional, defaults to GITHUB_TOKEN)'
    required: false

runs:
  using: composite
  steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github_token || github.token }}
        ref: ${{ github.event.pull_request.head.ref }}
        fetch-depth: 0
        persist-credentials: true

    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ inputs.go_version }}

    - name: Setup dependencies
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install --no-install-recommends -y jq
        go install github.com/avito-tech/go-mutesting/cmd/go-mutesting@v0.0.0-20250418092011-3ce278f4e19f

    - name: Detect module changes
      id: go_mod
      shell: bash
      env:
        BASE_REF: ${{ github.event.pull_request.base.ref }}
        BASE_REPO_URL: ${{ github.event.pull_request.base.repo.clone_url }}
      run: |
        set -euo pipefail

        # Add and fetch an upstream remote if missing
        if git remote get-url upstream &>/dev/null; then
          git remote set-url upstream "$BASE_REPO_URL"
        else
          git remote add upstream "$BASE_REPO_URL"
        fi
        git fetch --depth=1 upstream "$BASE_REF"

        DIFF_BASE="upstream/${BASE_REF}"

        # locate go.mod
        DIR="${{ inputs.directory }}"
        if [[ -z "$DIR" || "$DIR" == "." ]]; then
          MODPATH="go.mod"
          PROJECT_DIR="${GITHUB_WORKSPACE}"
        else
          DIR="${DIR%/}" # strip any trailing slash
          MODPATH="${DIR}/go.mod"
          PROJECT_DIR="${GITHUB_WORKSPACE}/${DIR}"
        fi

        # export for use in subsequent steps
        echo "GO_MOD_PATH=$MODPATH" >> "$GITHUB_OUTPUT"
        echo "PROJECT_DIR=$PROJECT_DIR" >> "$GITHUB_OUTPUT"

        if git diff --quiet "${DIFF_BASE}...HEAD" -- "$MODPATH"; then
          echo "changed=false" >> "$GITHUB_OUTPUT"
        else
          echo "changed=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Skip if no module changes
      if: steps.go_mod.outputs.changed == 'false'
      shell: bash
      run: |
        echo "✅ no changes in go.mod; skipping PatchLens analysis"

    - name: Detect platform and download PatchLens binaries
      if: steps.go_mod.outputs.changed == 'true'
      id: download
      shell: bash
      run: |
        VERSION="v0.0.3"
        echo "version=$VERSION" >> "$GITHUB_OUTPUT"
        set -euo pipefail

        # Auto-detect platform
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        # Normalize architecture names to match release naming
        case "$ARCH" in
          x86_64) ARCH="amd64" ;;
          aarch64|arm64) ARCH="arm64" ;;
          *) echo "❌ Unsupported architecture: $ARCH"; exit 1 ;;
        esac

        # Normalize OS names to match release naming
        case "$OS" in
          linux) OS="linux" ;;
          darwin) OS="darwin" ;;
          *) echo "❌ Unsupported OS: $OS"; exit 1 ;;
        esac

        echo "🖥️ Detected platform: ${OS}-${ARCH}"

        echo "⬇️ Downloading PatchLens binary version ${VERSION}..."

        # Download modlens binary
        BASE_URL="https://github.com/PatchLens/go-update-lens/releases/download/${VERSION}"
        MODLENS_URL="${BASE_URL}/modlens-${OS}-${ARCH}"
        echo "📥 Downloading modlens from: $MODLENS_URL"
        if ! curl -fsSL -o modlens "$MODLENS_URL"; then
          echo "❌ Failed to download modlens binary"
          echo "💡 Check if version ${VERSION} exists and supports" \
            "${OS}-${ARCH}"
          exit 1
        fi
        chmod +x modlens

        # Verify binary is executable
        if [[ ! -x ./modlens ]]; then
          echo "❌ modlens binary is not executable"
          exit 1
        fi

    - name: Get base go.mod for comparison
      if: steps.go_mod.outputs.changed == 'true'
      shell: bash
      env:
        BASE_REF: ${{ github.event.pull_request.base.ref }}
        GO_MOD_PATH: ${{ steps.go_mod.outputs.GO_MOD_PATH }}
        PROJECT_DIR: ${{ steps.go_mod.outputs.PROJECT_DIR }}
      run: |
        set -euo pipefail

        # Get base version of go.mod for comparison
        echo "📥 Fetching base go.mod from upstream/${BASE_REF}"
        git show "upstream/${BASE_REF}:${GO_MOD_PATH}" > "${PROJECT_DIR}/go.mod.base"

        # Save current go.mod as updated version
        cp "${GO_MOD_PATH}" "${PROJECT_DIR}/go.mod.updated"

    - name: Run PatchLens analysis
      if: steps.go_mod.outputs.changed == 'true'
      id: analysis
      shell: bash
      env:
        VERSION: ${{ steps.download.outputs.version }}
        PROJECT_DIR: ${{ steps.go_mod.outputs.PROJECT_DIR }}
        GO_MOD_PATH: ${{ steps.go_mod.outputs.GO_MOD_PATH }}
      run: |
        set -euo pipefail

        echo "📂 Project directory: ${PROJECT_DIR}"

        # First, use updated go.mod to download all dependencies
        echo "📦 Downloading modules..."
        cd "${PROJECT_DIR}"
        cp go.mod.updated go.mod
        go mod tidy
        go mod download all
        
        # Now use base go.mod to download base dependencies
        cp go.mod.base go.mod
        go mod tidy
        go mod download all
        cd "$GITHUB_WORKSPACE"

        echo "🚀 Running modlens analysis..."
        # run modlens analysis with updated go.mod
        ./modlens \
          -project "${PROJECT_DIR}" \
          -gomod "${PROJECT_DIR}/go.mod.updated" \
          -json "modreport.json" \
          -charts "modreport.png"
        MODLENS_EXIT_CODE=$?

        if [[ $MODLENS_EXIT_CODE -ne 0 ]]; then
          echo "⚠️ modlens analysis encountered issues" \
            "(exit code: $MODLENS_EXIT_CODE)"

          # Check if we got partial results
          if [[ -f "modreport.json" ]]; then
            echo "📊 Found partial results, continuing with report generation..."
          else
            echo "❌ No analysis results generated"
            echo "analysis_error=true" >> "$GITHUB_OUTPUT"
            echo "reachable_changed_function_count=0" >> "$GITHUB_OUTPUT"
            exit 1
          fi
        fi

        # check if we have results
        if [[ -f "modreport.json" ]]; then
          COUNT=$(jq -r \
            '.module.reachable_changed_function_count // 0' modreport.json)
          echo ""
          echo "📊 Analysis Summary:"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔄 Reachable changed functions: ${COUNT}"

          # Show module update summary if available
          jq -r '.module.summary // empty' modreport.json 2>/dev/null || true

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          echo "analysis_error=false" >> "$GITHUB_OUTPUT"
          printf 'reachable_changed_function_count=%d\n' \
            "$COUNT" >> "$GITHUB_OUTPUT"

          # Convert chart to base64 for upload step
          if [[ -f "modreport.png" ]]; then
            base64 -w 0 modreport.png > modreport.png.b64
          else
            echo "⚠️ No visual report generated, continuing without chart"
          fi
        else
          echo "❌ Analysis failed: no report generated"
          echo "analysis_error=true" >> "$GITHUB_OUTPUT"
          echo "reachable_changed_function_count=0" >> "$GITHUB_OUTPUT"
          exit 1
        fi

    - name: Upload report image to patchlens-assets branch
      id: upload_report
      if: steps.go_mod.outputs.changed == 'true' &&
          steps.analysis.outputs.analysis_error == 'false' &&
          steps.analysis.outputs.reachable_changed_function_count != '0'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token || github.token }}
        ASSETS_BRANCH: patchlens-assets
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        set -euo pipefail

        # prepare content
        if [[ ! -f "modreport.png.b64" ]]; then
          echo "⚠️ No chart data, skipping upload."
          echo "report_chart_url=" >> "$GITHUB_OUTPUT"
          echo "report_json_url=" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        B64=$(cat modreport.png.b64)

        git config --global user.name "github-actions[bot]"
        git config --global user.email \
          "github-actions[bot]@users.noreply.github.com"
        git fetch origin "$ASSETS_BRANCH" || true

        # fetch or create orphaned assets branch
        git reset --hard HEAD # reset go.sum / mod changes
        if git rev-parse --verify "origin/$ASSETS_BRANCH" >/dev/null 2>&1; then
          git checkout -B "$ASSETS_BRANCH" "origin/$ASSETS_BRANCH"
        else
          git checkout --orphan "$ASSETS_BRANCH"
          git rm -rf .
          git commit --allow-empty -m "Initialize $ASSETS_BRANCH branch"
        fi

        mkdir -p reports/
        REPO_NAME="${GITHUB_REPOSITORY##*/}"
        BASE="reports/${REPO_NAME}-${PR_NUMBER}-$(date +%s)"
        PNG_FILE="${BASE}.png"
        JSON_FILE="${BASE}.json"
        printf '%s\n' "$B64" | base64 --decode > "$PNG_FILE"
        cp modreport.json "$JSON_FILE"

        # add, commit, and push with retry on conflict
        git add "$PNG_FILE" "$JSON_FILE"
        git commit -m \
          "PatchLens report for ${REPO_NAME} PR #${PR_NUMBER}"
        for i in {1..10}; do
          if git push origin "$ASSETS_BRANCH"; then
            break
          else
            printf '⚠️ Push conflict (attempt %d), fetching…\n' "$i" >&2
            git pull --rebase origin "$ASSETS_BRANCH"
          fi
        done

        # export raw URLs for the next comment step
        BASE_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${ASSETS_BRANCH}"
        printf 'report_chart_url=%s\n' \
          "${BASE_URL}/${PNG_FILE}" >> "$GITHUB_OUTPUT"
        printf 'report_json_url=%s\n' \
          "${BASE_URL}/${JSON_FILE}" >> "$GITHUB_OUTPUT"

    - name: Comment results on PR (not reachable)
      if: steps.go_mod.outputs.changed == 'true' &&
          steps.analysis.outputs.analysis_error == 'false' &&
          steps.analysis.outputs.reachable_changed_function_count == '0'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token || github.token }}
        script: |
          // delete old PatchLens comments
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            per_page: 100
          });
          for (const c of comments) {
            if (c.user.login === 'github-actions[bot]' &&
                c.body.startsWith('## 🔍 PatchLens Analysis Report')) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: c.id
              });
            }
          }

          // post simple “not reachable” message
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: [
              '## 🔍 PatchLens Analysis Report',
              '',
              'Module changes not reachable by project'
            ].join('\n')
          });

    - name: Comment results on PR (normal report)
      if: steps.go_mod.outputs.changed == 'true' &&
          steps.analysis.outputs.analysis_error == 'false' &&
          steps.analysis.outputs.reachable_changed_function_count != '0'
      uses: actions/github-script@v7
      env:
        REPORT_CHART_URL: ${{ steps.upload_report.outputs.report_chart_url }}
        REPORT_JSON_URL: ${{ steps.upload_report.outputs.report_json_url }}
      with:
        github-token: ${{ inputs.github_token || github.token }}
        script: |
          const chartUrl = process.env.REPORT_CHART_URL;
          const jsonUrl = process.env.REPORT_JSON_URL;
          if (!chartUrl) {
            core.info('⚠️ No report URL, skipping comment.');
            return;
          }

          // delete old PatchLens comments
          const { data: comments } = await github.rest.issues.listComments({
            owner:        context.repo.owner,
            repo:         context.repo.repo,
            issue_number: context.issue.number,
            per_page:     100
          });
          for (const c of comments) {
            if (c.user.login === 'github-actions[bot]' &&
                c.body.startsWith('## 🔍 PatchLens Analysis Report')) {
              await github.rest.issues.deleteComment({
                owner:      context.repo.owner,
                repo:       context.repo.repo,
                comment_id: c.id
              });
            }
          }

          // post the report image + JSON link
          await github.rest.issues.createComment({
            owner:        context.repo.owner,
            repo:         context.repo.repo,
            issue_number: context.issue.number,
            body: [
              '## 🔍 PatchLens Analysis Report',
              '',
              `![PatchLens Report](${chartUrl})`,
              '',
              `📄 [Download detailed JSON report](${jsonUrl})`,
              ''
            ].join('\n')
          });
